# Filtrer seulement celles qui pourraient être des anastomoses
interventions_potentielles <- interventions_manquantes[grepl("anastomose|bilio|rétablissement|bypass|colectomie|rectum|transplant",
interventions_manquantes, ignore.case = TRUE)]
print(interventions_potentielles)
##--------------------------------------------
##-------NOTATION DES OPÉRATEURS--------
# Système de notation des opérateurs sur 20
# 1/3 pour le taux de geste, 1/3 pour la pédagogie, 1/3 pour l'ambiance
library(dplyr)
# 1. Calculer le taux de geste par opérateur (quand c'est un bloc avec eux)
taux_geste_operateur <- df %>%
filter(!is.na(OPERATEUR), !is.na(Geste)) %>%
group_by(OPERATEUR) %>%
summarise(
nombre_interventions = n(),
nombre_gestes = sum(Geste == "Yes", na.rm = TRUE),
taux_geste = round((nombre_gestes / nombre_interventions) * 100, 2),
.groups = 'drop'
)
# 2. Calculer les scores moyens de PEDAGOGIE et AMBIANCE par opérateur
scores_operateur <- df %>%
filter(!is.na(OPERATEUR)) %>%
group_by(OPERATEUR) %>%
summarise(
# Pédagogie (1-5)
score_pedagogie_moyen = round(mean(as.numeric(PEDAGOGIE), na.rm = TRUE), 2),
# Ambiance (1-3)
score_ambiance_moyen = round(mean(as.numeric(AMBIANCE), na.rm = TRUE), 2),
nombre_evaluations = n(),
.groups = 'drop'
)
# 3. Joindre les données et calculer la note globale sur 20
notation_operateurs <- taux_geste_operateur %>%
left_join(scores_operateur, by = "OPERATEUR") %>%
filter(!is.na(score_pedagogie_moyen), !is.na(score_ambiance_moyen)) %>%
mutate(
# Normaliser chaque composante sur 20/3 (soit environ 6.67 points chacune)
note_taux_geste = (taux_geste / 100) * (20/3),  # Taux de geste normalisé
note_pedagogie = ((score_pedagogie_moyen - 1) / (5 - 1)) * (20/3),  # Pédagogie normalisée (1-5 -> 0-6.67)
note_ambiance = ((score_ambiance_moyen - 1) / (3 - 1)) * (20/3),   # Ambiance normalisée (1-3 -> 0-6.67)
# Note globale = somme des 3 composantes
note_globale = round(note_taux_geste + note_pedagogie + note_ambiance, 2)
) %>%
# Arrondir les composantes pour plus de lisibilité
mutate(
note_taux_geste = round(note_taux_geste, 2),
note_pedagogie = round(note_pedagogie, 2),
note_ambiance = round(note_ambiance, 2)
)
notation_operateurs <- notation_operateurs %>%
filter(nombre_interventions >= 10)
# 4. Créer les tableaux de classement
# Tableau 1: Classement par note globale
classement_note_globale <- notation_operateurs %>%
arrange(desc(note_globale)) %>%
select(OPERATEUR, note_globale, note_taux_geste, note_pedagogie, note_ambiance,
taux_geste, score_pedagogie_moyen, score_ambiance_moyen, nombre_interventions) %>%
mutate(rang_global = row_number())
# Tableau 2: Classement par taux de geste
classement_taux_geste <- notation_operateurs %>%
arrange(desc(taux_geste)) %>%
select(OPERATEUR, taux_geste, note_taux_geste, nombre_gestes, nombre_interventions) %>%
mutate(rang_taux_geste = row_number())
# Tableau 3: Classement par pédagogie
classement_pedagogie <- notation_operateurs %>%
arrange(desc(score_pedagogie_moyen)) %>%
select(OPERATEUR, score_pedagogie_moyen, note_pedagogie, nombre_evaluations) %>%
mutate(rang_pedagogie = row_number())
# Tableau 4: Classement par ambiance
classement_ambiance <- notation_operateurs %>%
arrange(desc(score_ambiance_moyen)) %>%
select(OPERATEUR, score_ambiance_moyen, note_ambiance, nombre_evaluations) %>%
mutate(rang_ambiance = row_number())
# 5. Tableau final consolidé avec tous les classements
tableau_final_operateurs <- notation_operateurs %>%
left_join(
classement_note_globale %>% select(OPERATEUR, rang_global),
by = "OPERATEUR"
) %>%
left_join(
classement_taux_geste %>% select(OPERATEUR, rang_taux_geste),
by = "OPERATEUR"
) %>%
left_join(
classement_pedagogie %>% select(OPERATEUR, rang_pedagogie),
by = "OPERATEUR"
) %>%
left_join(
classement_ambiance %>% select(OPERATEUR, rang_ambiance),
by = "OPERATEUR"
) %>%
select(
OPERATEUR,
note_globale, rang_global,
taux_geste, rang_taux_geste,
score_pedagogie_moyen, rang_pedagogie,
score_ambiance_moyen, rang_ambiance,
nombre_interventions, nombre_evaluations
) %>%
arrange(rang_global)
# Affichage des résultats
print("=== TOP 10 - CLASSEMENT GÉNÉRAL ===")
print(tableau_final_operateurs %>% head(10))
print("\n=== TOP 10 - TAUX DE GESTE ===")
print(classement_taux_geste %>% head(10))
print("\n=== TOP 10 - PÉDAGOGIE ===")
print(classement_pedagogie %>% head(10))
print("\n=== TOP 10 - AMBIANCE ===")
print(classement_ambiance %>% head(10))
#répartition des opérateurs selon RANG_BOSS
repartition_rang_boss <- df %>%
filter(!is.na(OPERATEUR), !is.na(RANG_BOSS)) %>%
group_by(OPERATEUR, RANG_BOSS) %>%
summarise(nombre_interventions = n(), .groups = 'drop') %>%
group_by(OPERATEUR) %>%
mutate(pourcentage = round((nombre_interventions / sum(nombre_interventions)) * 100, 2)) %>%
arrange(OPERATEUR, desc(pourcentage))
print("\n=== RÉPARTITION DES OPÉRATEURS SELON RANG_BOSS ===")
print(repartition_rang_boss, n=200)
suppressPackageStartupMessages({library(dplyr); library(readr)})
#APP répartition
# ---- App Shiny : unifier RANG_BOSS par opérateur (radio + auto-save)
# PRÉREQUIS : un objet df en mémoire avec colonnes OPERATEUR et RANG_BOSS
suppressPackageStartupMessages({
library(shiny)
library(dplyr)
library(readr)
library(stringr)
library(tidyr)
})
# petite fonction "mode" pour proposer un rang par défaut
.mode_chr <- function(x) {
x <- x[!is.na(x) & x != ""]
if (!length(x)) return(NA_character_)
tb <- sort(table(x), decreasing = TRUE)
top <- tb[tb == max(tb)]
sort(names(top))[1]
}
# données de base
stopifnot(all(c("OPERATEUR","RANG_BOSS") %in% names(df)))
ops <- df %>%
filter(!is.na(OPERATEUR), OPERATEUR != "") %>%
mutate(OPERATEUR = trimws(OPERATEUR)) %>%
distinct(OPERATEUR) %>%
arrange(OPERATEUR) %>%
pull(OPERATEUR)
rang_choices <- c("PU", "PH", "CCA", "MCU", "DJ")
# synthèse pour afficher les rangs observés par opérateur
synth <- df %>%
filter(!is.na(OPERATEUR), OPERATEUR != "", !is.na(RANG_BOSS), RANG_BOSS != "") %>%
mutate(across(c(OPERATEUR, RANG_BOSS), ~trimws(as.character(.)))) %>%
count(OPERATEUR, RANG_BOSS, name = "n") %>%
arrange(OPERATEUR, desc(n), RANG_BOSS) %>%
group_by(OPERATEUR) %>%
mutate(proposition = .mode_chr(RANG_BOSS),
info = paste0(RANG_BOSS, ":", n, collapse = " | ")) %>%
ungroup() %>%
distinct(OPERATEUR, proposition, info)
# charge mapping existant si présent; sinon initialise avec NA (et une proposition)
map_path <- "operateur_rang_map.csv"
if (file.exists(map_path)) {
base_map <- read_csv(map_path, show_col_types = FALSE) %>%
mutate(across(everything(), ~trimws(as.character(.x)))) %>%
right_join(tibble(OPERATEUR = ops), by = "OPERATEUR") %>%
left_join(synth %>% select(OPERATEUR, proposition), by = "OPERATEUR") %>%
transmute(
OPERATEUR,
RANG_BOSS_CANONIQUE = if_else(!is.na(RANG_BOSS_CANONIQUE) & RANG_BOSS_CANONIQUE != "",
RANG_BOSS_CANONIQUE, NA_character_),
PROPOSITION = proposition
)
} else {
base_map <- tibble(
OPERATEUR = ops
) %>%
left_join(synth %>% select(OPERATEUR, proposition), by = "OPERATEUR") %>%
transmute(
OPERATEUR,
RANG_BOSS_CANONIQUE = NA_character_,
PROPOSITION = proposition
)
}
ui <- fluidPage(
titlePanel("Unification des RANG_BOSS (choix unique, sauvegarde automatique)"),
fluidRow(
column(5,
selectInput("operateur", "Opérateur :", choices = ops, width = "100%"),
uiOutput("observes"),
radioButtons("rang", "Rang retenu :", choices = rang_choices, selected = character(0)),
helpText("Le choix est enregistré instantanément dans operateur_rang_map.csv")
),
column(7,
h4("Mapping actuel"),
div(style = "max-height: 60vh; overflow-y: auto;",
tableOutput("mapTable")),
br(),
downloadButton("dl_map", "Télécharger le mapping (CSV)")
)
)
)
server <- function(input, output, session) {
mapping <- reactiveVal(base_map)
# afficher les rangs observés + proposition pour l'opérateur sélectionné
output$observes <- renderUI({
op <- req(input$operateur)
row <- synth %>% filter(OPERATEUR == op)
info <- if (nrow(row)) row$info[[1]] else "(aucun rang observé)"
prop <- if (nrow(row)) row$proposition[[1]] else NA_character_
tagList(
p(HTML(paste0("<b>Rangs observés :</b> ", htmltools::htmlEscape(info)))),
if (!is.na(prop)) tags$small(paste("Proposition :", prop)) else NULL
)
})
# quand on change d'opérateur, on positionne le radio :
# 1) valeur déjà mappée si existante
# 2) sinon, proposition (mode observé)
observeEvent(input$operateur, {
m <- mapping()
op <- input$operateur
current <- m$RANG_BOSS_CANONIQUE[m$OPERATEUR == op]
prop <- m$PROPOSITION[m$OPERATEUR == op]
sel <- if (!is.na(current) && nzchar(current)) current else if (!is.na(prop)) prop else character(0)
updateRadioButtons(session, "rang", selected = sel)
}, ignoreInit = TRUE)
# quand on change le radio, on met à jour le mapping et on ÉCRIT le CSV (auto-save)
observeEvent(input$rang, {
op <- req(input$operateur)
choix <- req(input$rang)
# sécurise : forcer choix dans la liste autorisée
if (!choix %in% rang_choices) return(NULL)
m <- mapping()
m$RANG_BOSS_CANONIQUE[m$OPERATEUR == op] <- choix
mapping(m)
# auto-save
write_csv(m %>% select(OPERATEUR, RANG_BOSS_CANONIQUE), map_path)
showNotification(paste0("Enregistré: ", op, " → ", choix), type = "message", duration = 1.5)
}, ignoreInit = TRUE)
output$mapTable <- renderTable({
mapping() %>%
select(OPERATEUR, RANG_BOSS_CANONIQUE, PROPOSITION)
})
output$dl_map <- downloadHandler(
filename = function() paste0("operateur_rang_map_", format(Sys.time(), "%Y%m%d-%H%M%S"), ".csv"),
content = function(file) {
readr::write_csv(mapping() %>% select(OPERATEUR, RANG_BOSS_CANONIQUE), file)
}
)
}
shinyApp(ui, server)
suppressPackageStartupMessages({library(dplyr); library(readr); library(stringr)})
map_path <- "~/Documents/R/Logbook/operateur_rang_map_20250920-083619.csv"
# 1) Charge et nettoie le mapping
rang_allowed <- c("PU","PH","CCA","MCU","DJ")
map <- read_csv(map_path, show_col_types = FALSE) %>%
mutate(across(everything(), ~trimws(as.character(.x)))) %>%
rename_with(~"OPERATEUR", .cols = matches("^OPERATEUR$", ignore.case = TRUE)) %>%
rename_with(~"RANG_BOSS_CANONIQUE", .cols = matches("^RANG_BOSS_CANONIQUE$", ignore.case = TRUE)) %>%
mutate(RANG_BOSS_CANONIQUE = if_else(RANG_BOSS_CANONIQUE %in% rang_allowed, RANG_BOSS_CANONIQUE, NA_character_))
##-------NOTATION DES OPÉRATEURS--------
# Système de notation des opérateurs sur 20
# 1/3 pour le taux de geste, 1/3 pour la pédagogie, 1/3 pour l'ambiance
library(dplyr)
# 1. Calculer le taux de geste par opérateur (quand c'est un bloc avec eux)
taux_geste_operateur <- df %>%
filter(!is.na(OPERATEUR), !is.na(Geste)) %>%
group_by(OPERATEUR) %>%
summarise(
nombre_interventions = n(),
nombre_gestes = sum(Geste == "Yes", na.rm = TRUE),
taux_geste = round((nombre_gestes / nombre_interventions) * 100, 2),
.groups = 'drop'
)
# 2. Calculer les scores moyens de PEDAGOGIE et AMBIANCE par opérateur
scores_operateur <- df %>%
filter(!is.na(OPERATEUR)) %>%
group_by(OPERATEUR) %>%
summarise(
# Pédagogie (1-5)
score_pedagogie_moyen = round(mean(as.numeric(PEDAGOGIE), na.rm = TRUE), 2),
# Ambiance (1-3)
score_ambiance_moyen = round(mean(as.numeric(AMBIANCE), na.rm = TRUE), 2),
nombre_evaluations = n(),
.groups = 'drop'
)
# 3. Joindre les données et calculer la note globale sur 20
notation_operateurs <- taux_geste_operateur %>%
left_join(scores_operateur, by = "OPERATEUR") %>%
filter(!is.na(score_pedagogie_moyen), !is.na(score_ambiance_moyen)) %>%
mutate(
# Normaliser chaque composante sur 20/3 (soit environ 6.67 points chacune)
note_taux_geste = (taux_geste / 100) * (20/3),  # Taux de geste normalisé
note_pedagogie = ((score_pedagogie_moyen - 1) / (5 - 1)) * (20/3),  # Pédagogie normalisée (1-5 -> 0-6.67)
note_ambiance = ((score_ambiance_moyen - 1) / (3 - 1)) * (20/3),   # Ambiance normalisée (1-3 -> 0-6.67)
# Note globale = somme des 3 composantes
note_globale = round(note_taux_geste + note_pedagogie + note_ambiance, 2)
) %>%
# Arrondir les composantes pour plus de lisibilité
mutate(
note_taux_geste = round(note_taux_geste, 2),
note_pedagogie = round(note_pedagogie, 2),
note_ambiance = round(note_ambiance, 2)
)
notation_operateurs <- notation_operateurs %>%
filter(nombre_interventions >= 10)
# 4. Créer les tableaux de classement
# Tableau 1: Classement par note globale
classement_note_globale <- notation_operateurs %>%
arrange(desc(note_globale)) %>%
select(OPERATEUR, note_globale, note_taux_geste, note_pedagogie, note_ambiance,
taux_geste, score_pedagogie_moyen, score_ambiance_moyen, nombre_interventions) %>%
mutate(rang_global = row_number())
# Tableau 2: Classement par taux de geste
classement_taux_geste <- notation_operateurs %>%
arrange(desc(taux_geste)) %>%
select(OPERATEUR, taux_geste, note_taux_geste, nombre_gestes, nombre_interventions) %>%
mutate(rang_taux_geste = row_number())
# Tableau 3: Classement par pédagogie
classement_pedagogie <- notation_operateurs %>%
arrange(desc(score_pedagogie_moyen)) %>%
select(OPERATEUR, score_pedagogie_moyen, note_pedagogie, nombre_evaluations) %>%
mutate(rang_pedagogie = row_number())
# Tableau 4: Classement par ambiance
classement_ambiance <- notation_operateurs %>%
arrange(desc(score_ambiance_moyen)) %>%
select(OPERATEUR, score_ambiance_moyen, note_ambiance, nombre_evaluations) %>%
mutate(rang_ambiance = row_number())
# 5. Tableau final consolidé avec tous les classements
tableau_final_operateurs <- notation_operateurs %>%
left_join(
classement_note_globale %>% select(OPERATEUR, rang_global),
by = "OPERATEUR"
) %>%
left_join(
classement_taux_geste %>% select(OPERATEUR, rang_taux_geste),
by = "OPERATEUR"
) %>%
left_join(
classement_pedagogie %>% select(OPERATEUR, rang_pedagogie),
by = "OPERATEUR"
) %>%
left_join(
classement_ambiance %>% select(OPERATEUR, rang_ambiance),
by = "OPERATEUR"
) %>%
select(
OPERATEUR,
note_globale, rang_global,
taux_geste, rang_taux_geste,
score_pedagogie_moyen, rang_pedagogie,
score_ambiance_moyen, rang_ambiance,
nombre_interventions, nombre_evaluations
) %>%
arrange(rang_global)
# Affichage des résultats
print("=== TOP 10 - CLASSEMENT GÉNÉRAL ===")
print(tableau_final_operateurs %>% head(10))
print("\n=== TOP 10 - TAUX DE GESTE ===")
print(classement_taux_geste %>% head(10))
print("\n=== TOP 10 - PÉDAGOGIE ===")
print(classement_pedagogie %>% head(10))
print("\n=== TOP 10 - AMBIANCE ===")
print(classement_ambiance %>% head(10))
#répartition des opérateurs selon RANG_BOSS
repartition_rang_boss <- df %>%
filter(!is.na(OPERATEUR), !is.na(RANG_BOSS)) %>%
group_by(OPERATEUR, RANG_BOSS) %>%
summarise(nombre_interventions = n(), .groups = 'drop') %>%
group_by(OPERATEUR) %>%
mutate(pourcentage = round((nombre_interventions / sum(nombre_interventions)) * 100, 2)) %>%
arrange(OPERATEUR, desc(pourcentage))
print("\n=== RÉPARTITION DES OPÉRATEURS SELON RANG_BOSS ===")
print(repartition_rang_boss, n=200)
suppressPackageStartupMessages({library(dplyr); library(readr)})
#APP répartition
# ---- App Shiny : unifier RANG_BOSS par opérateur (radio + auto-save)
# PRÉREQUIS : un objet df en mémoire avec colonnes OPERATEUR et RANG_BOSS
suppressPackageStartupMessages({
library(shiny)
library(dplyr)
library(readr)
library(stringr)
library(tidyr)
})
# petite fonction "mode" pour proposer un rang par défaut
.mode_chr <- function(x) {
x <- x[!is.na(x) & x != ""]
if (!length(x)) return(NA_character_)
tb <- sort(table(x), decreasing = TRUE)
top <- tb[tb == max(tb)]
sort(names(top))[1]
}
# données de base
stopifnot(all(c("OPERATEUR","RANG_BOSS") %in% names(df)))
ops <- df %>%
filter(!is.na(OPERATEUR), OPERATEUR != "") %>%
mutate(OPERATEUR = trimws(OPERATEUR)) %>%
distinct(OPERATEUR) %>%
arrange(OPERATEUR) %>%
pull(OPERATEUR)
rang_choices <- c("PU", "PH", "CCA", "MCU", "DJ")
# synthèse pour afficher les rangs observés par opérateur
synth <- df %>%
filter(!is.na(OPERATEUR), OPERATEUR != "", !is.na(RANG_BOSS), RANG_BOSS != "") %>%
mutate(across(c(OPERATEUR, RANG_BOSS), ~trimws(as.character(.)))) %>%
count(OPERATEUR, RANG_BOSS, name = "n") %>%
arrange(OPERATEUR, desc(n), RANG_BOSS) %>%
group_by(OPERATEUR) %>%
mutate(proposition = .mode_chr(RANG_BOSS),
info = paste0(RANG_BOSS, ":", n, collapse = " | ")) %>%
ungroup() %>%
distinct(OPERATEUR, proposition, info)
# charge mapping existant si présent; sinon initialise avec NA (et une proposition)
map_path <- "operateur_rang_map.csv"
if (file.exists(map_path)) {
base_map <- read_csv(map_path, show_col_types = FALSE) %>%
mutate(across(everything(), ~trimws(as.character(.x)))) %>%
right_join(tibble(OPERATEUR = ops), by = "OPERATEUR") %>%
left_join(synth %>% select(OPERATEUR, proposition), by = "OPERATEUR") %>%
transmute(
OPERATEUR,
RANG_BOSS_CANONIQUE = if_else(!is.na(RANG_BOSS_CANONIQUE) & RANG_BOSS_CANONIQUE != "",
RANG_BOSS_CANONIQUE, NA_character_),
PROPOSITION = proposition
)
} else {
base_map <- tibble(
OPERATEUR = ops
) %>%
left_join(synth %>% select(OPERATEUR, proposition), by = "OPERATEUR") %>%
transmute(
OPERATEUR,
RANG_BOSS_CANONIQUE = NA_character_,
PROPOSITION = proposition
)
}
ui <- fluidPage(
titlePanel("Unification des RANG_BOSS (choix unique, sauvegarde automatique)"),
fluidRow(
column(5,
selectInput("operateur", "Opérateur :", choices = ops, width = "100%"),
uiOutput("observes"),
radioButtons("rang", "Rang retenu :", choices = rang_choices, selected = character(0)),
helpText("Le choix est enregistré instantanément dans operateur_rang_map.csv")
),
column(7,
h4("Mapping actuel"),
div(style = "max-height: 60vh; overflow-y: auto;",
tableOutput("mapTable")),
br(),
downloadButton("dl_map", "Télécharger le mapping (CSV)")
)
)
)
server <- function(input, output, session) {
mapping <- reactiveVal(base_map)
# afficher les rangs observés + proposition pour l'opérateur sélectionné
output$observes <- renderUI({
op <- req(input$operateur)
row <- synth %>% filter(OPERATEUR == op)
info <- if (nrow(row)) row$info[[1]] else "(aucun rang observé)"
prop <- if (nrow(row)) row$proposition[[1]] else NA_character_
tagList(
p(HTML(paste0("<b>Rangs observés :</b> ", htmltools::htmlEscape(info)))),
if (!is.na(prop)) tags$small(paste("Proposition :", prop)) else NULL
)
})
# quand on change d'opérateur, on positionne le radio :
# 1) valeur déjà mappée si existante
# 2) sinon, proposition (mode observé)
observeEvent(input$operateur, {
m <- mapping()
op <- input$operateur
current <- m$RANG_BOSS_CANONIQUE[m$OPERATEUR == op]
prop <- m$PROPOSITION[m$OPERATEUR == op]
sel <- if (!is.na(current) && nzchar(current)) current else if (!is.na(prop)) prop else character(0)
updateRadioButtons(session, "rang", selected = sel)
}, ignoreInit = TRUE)
# quand on change le radio, on met à jour le mapping et on ÉCRIT le CSV (auto-save)
observeEvent(input$rang, {
op <- req(input$operateur)
choix <- req(input$rang)
# sécurise : forcer choix dans la liste autorisée
if (!choix %in% rang_choices) return(NULL)
m <- mapping()
m$RANG_BOSS_CANONIQUE[m$OPERATEUR == op] <- choix
mapping(m)
# auto-save
write_csv(m %>% select(OPERATEUR, RANG_BOSS_CANONIQUE), map_path)
showNotification(paste0("Enregistré: ", op, " → ", choix), type = "message", duration = 1.5)
}, ignoreInit = TRUE)
output$mapTable <- renderTable({
mapping() %>%
select(OPERATEUR, RANG_BOSS_CANONIQUE, PROPOSITION)
})
output$dl_map <- downloadHandler(
filename = function() paste0("operateur_rang_map_", format(Sys.time(), "%Y%m%d-%H%M%S"), ".csv"),
content = function(file) {
readr::write_csv(mapping() %>% select(OPERATEUR, RANG_BOSS_CANONIQUE), file)
}
)
}
shinyApp(ui, server)
suppressPackageStartupMessages({library(dplyr); library(readr); library(stringr)})
map_path <- "~/Documents/R/Logbook/operateur_rang_map_20250920-083619.csv"
# 1) Charge et nettoie le mapping
rang_allowed <- c("PU","PH","CCA","MCU","DJ")
map <- read_csv(map_path, show_col_types = FALSE) %>%
mutate(across(everything(), ~trimws(as.character(.x)))) %>%
rename_with(~"OPERATEUR", .cols = matches("^OPERATEUR$", ignore.case = TRUE)) %>%
rename_with(~"RANG_BOSS_CANONIQUE", .cols = matches("^RANG_BOSS_CANONIQUE$", ignore.case = TRUE)) %>%
mutate(RANG_BOSS_CANONIQUE = if_else(RANG_BOSS_CANONIQUE %in% rang_allowed, RANG_BOSS_CANONIQUE, NA_character_))
View(notation_operateurs)
